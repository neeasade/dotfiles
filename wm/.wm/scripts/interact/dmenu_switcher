#!/usr/bin/env bash
# all switcher dmenu
# idea: qutebrowser history
# idea: org headings

declare -A matches_to_actions

add_switch() {
  matches_to_actions["$1"]=$2
}

add_windows() {
    for wid in $(bspc query -N -n .leaf); do
	add_switch "window: $(xtitle $wid)" "bspc node $wid -g hidden=off; bspc node -f $wid"
    done
}

add_emacs_buffers() {
    find_emacs_window() {
	emacs_wid=
	check_id() {
	    wid=$1
	    if [ ! -z "$emacs_wid" ]; then
		return 0
	    fi

	    if xprop -id $wid | grep WM_CLASS | grep Emacs; then
		emacs_wid=$wid
		return 0
	    fi
	    return 1
	}

	check_id $(bspc query -N -n)
	for wid in $(bspc query -N -d focused -n .leaf); do
	    check_id $wid && break
	done

	if [ -z "$emacs_wid" ]; then
	    elisp '(ns/spawn-terminal)'
	    check_id $(bspc query -N -n)
	fi

	bspc node -f $emacs_wid
    }

    emacs_find_file() {
	find_emacs_window
	elisp "(find-file \"${*}\")"
    }

    emacs_find_buffer() {
	find_emacs_window
	elisp "(-> \"${*}\" get-buffer switch-to-buffer)"
    }

    IFS=$'\n'
    buffers=$(elisp -r '(->> (ns/jump-file-candidates) (mapcar (function s-clean)) (ns/make-lines))')
    for buffer in $buffers; do
	# note: this will break if ever switching to a file with a ' in the name
	add_switch "file: $buffer" "emacs_find_file '$buffer'"
    done

    buffers=$(elisp -r "(->> (buffer-list) (-filter (fn (not (buffer-file-name <>)))) (mapcar 'buffer-name) (ns/make-lines))")
    for buffer in $buffers; do
	# note: this will break if ever switching to a file with a ' in the name
	add_switch "buffer: $buffer" "emacs_find_buffer '$buffer'"
    done
}

add_qutebrowser_tabs() {
    open_titles() {
	grep -A 6 '    \- active: true' "$HOME/.local/share/qutebrowser/sessions/default.yml" | grep title | sed 's/.*title: //'
    }

    qute_switch_to() {
	title=$*
	qb_title=$(bspc query -N -n .leaf | xargs xtitle | grep  '\- qutebrowser' | head -n 1)
	select_action "window: $qb_title"
	qb_command ":buffer $title"
    }

    while read -r title; do
	add_switch "tab: $title" "qute_switch_to '$(echo "$title" | sed "s/'//g;s/\"// ")'"
    done <<< "$(open_titles)"
}

select_action() {
  # allow partial match
  # target=$(echo "$options" | grep "$*" | head -n 1)
    target=$*
    echo "$target"
    echo "${matches_to_actions[${target}]}"
    eval "${matches_to_actions[${target}]}"
}

add_windows
add_qutebrowser_tabs
add_emacs_buffers

choice=$((for key in "${!matches_to_actions[@]}"; do
		echo "$key"
	    done
) | dmenu "$@")

select_action "$choice"
