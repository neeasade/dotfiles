#!/usr/bin/env bash
# all switcher dmenu
# idea: qutebrowser history
# idea: org headings
# on the emacs side could really use keybinds to narrow

declare -A matches_to_actions

add_switch() {
    matches_to_actions["$1"]=$2
}

add_windows() {
    reveal_window() {
	wid=$1
	bspc node $wid -g hidden=off
	bspc node -f $wid
    }

    for wid in $(bspc query -N -n .window); do
	add_switch "window: $(xtitle $wid)" "reveal_window $wid"
    done
}

add_emacs_buffers() {
    find_emacs_window() {
	emacs_wid=
	check_id() {
	    wid=$1
	    if [ ! -z "$emacs_wid" ]; then
		return 0
	    fi

	    if xprop -id $wid | grep WM_CLASS | grep Emacs; then
		emacs_wid=$wid
		return 0
	    fi
	    return 1
	}

	check_id $(bspc query -N -n)
	for wid in $(bspc query -N -d focused -n .leaf); do
	    check_id $wid && break
	done

	if [ -z "$emacs_wid" ]; then
	    elisp '(ns/spawn-terminal)'
	    check_id $(bspc query -N -n)
	fi

	bspc node -f $emacs_wid
    }

    emacs_find_file() {
	find_emacs_window
	elisp "(find-file \"${*}\")"
    }

    emacs_find_buffer() {
	find_emacs_window
	elisp "(-> \"${*}\" get-buffer switch-to-buffer)"
    }

    IFS=$'\n'
    buffers=$(elisp -r '(->> (ns/jump-file-candidates) (mapcar (function s-clean)) (ns/make-lines))')
    for buffer in $buffers; do
	# note: this will break if ever switching to a file with a ' in the name
	add_switch "file: $buffer" "emacs_find_file '$buffer'"
    done

    buffers=$(elisp -r "(->> (buffer-list) (-filter (fn (not (buffer-file-name <>)))) (mapcar 'buffer-name) (ns/make-lines))")
    for buffer in $buffers; do
	# note: this will break if ever switching to a file with a ' in the name
	add_switch "buffer: $buffer" "emacs_find_buffer '$buffer'"
    done
}

add_qutebrowser_history() {
    start_day=$(date --date="1 days ago" +%F)
    end_day=$(date +%F)
    start=$(date -d "$start_day 00:00:00" +%s)
    end=$(date -d "$end_day 23:59:59" +%s)
    query="select * from history where atime > ${start} and atime < ${end}"
    qutedb="$HOME/.local/share/qutebrowser/history.sqlite"

    while read -r result; do
	url=$(awk -F\| '{print $1}' <<<"$result")
	title=$(awk -F\| '{print $2}' <<<"$result")
	# echo "add_switch history: $title notify-send wtf"
	add_switch "history: $title" "notify-send wtf"
    done < <(sqlite3 "$qutedb" "$query" | head -n 2)
}

add_qutebrowser_tabs() {
    open_titles() {
	grep -A 6 '    \- active: true' "$HOME/.local/share/qutebrowser/sessions/_autosave.yml" | grep title | sed 's/.*title: //'
    }

    # user by add_meta as well
    qute_switch_to() {
	title=$*
	qb_meta_open
	qb_command ":buffer $title"
    }

    while read -r title; do
	add_switch "tab: $title" "qute_switch_to '$(echo "$title" | sed "s/'//g;s/\"// ")'"
    done <<< "$(open_titles)"
}

# playing around
# idea: meta history that opens up new dmenu with qutebrowser browsing history from sqlite
# idea: find a current window with shell on vps or spawn one
add_meta() {
    find_url() {
	url_match=$*
	session_file="${HOME}/.local/share/qutebrowser/sessions/_autosave.yml"
	open_urls=$(sed -E '/^  geometry/,+2d' "$session_file" | yq -r '.windows[0].tabs[] | .history[-1].url')
	if echo "$open_urls" | grep "$url_match"; then
	    qute_switch_to "$url_match"
	else
	    $BROWSER "$url_match"
	fi
    }

    add_switch "meta: zulip" "find_url 'https://recurse.zulipchat.com'"
    add_switch "meta: telegram" "https://web.telegram.org/"
    add_switch "meta: twitter" "find_url 'https://twitter.com'"

    find_steam() {
	if pgrep steam; then
	    # seems to be constant
	    select_action "window: Steam"
	else
	    steam
	fi
    }

    add_switch "meta: steam" "find_steam"

    find_last_irc_ping() {
	echo todo
    }

    add_switch "meta: org capture" "elisp '(ns/org-capture-popup)'"

    # idea: hydra menu for tag stuff? other?

    notes_file() {
	echo todo
    }
}

select_action() {
    # maybe consider allow partial match later (turned out accumulating options was really slow/maybe revisit this in keys)

    if [ -z "$*" ]; then
	return
    fi

    # target=$(echo "$options" | grep "$*" | head -n 1)
    target=$*
    echo "$target"
    echo "${matches_to_actions[${target}]}"
    eval "${matches_to_actions[${target}]}"
    # bspc desktop -l monocle
}

# doing it this way let's us call dmenu right away/just start typing
enact() {
    add_windows >/dev/null
    add_qutebrowser_tabs >/dev/null
    add_emacs_buffers >/dev/null
    add_meta >/dev/null
    add_qutebrowser_history >/dev/null

    for key in "${!matches_to_actions[@]}"; do
	echo "$key"
    done
}

choice=$(enact | dmenu "$@")
select_action "$choice"
