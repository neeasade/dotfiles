#!/usr/bin/env bash

prompt=${*:-select}

# cheat a little: if called like regular dmenu ignore everything except -p
while :; do
    while getopts 'p:' flag 2>/dev/null; do
	case $flag in
	    p) prompt=$OPTARG;;
	    *) ;; # nop
	esac
    done
    ((OPTIND++))
    [ $OPTIND -gt $# ] && break
done

# wowie wow oh my
read_input() {
    read -r first_line;
    include=true
    if [[ $first_line == FEEDER_PID* ]]; then
	eval "$first_line"
	include=false
    fi

    if $include; then
	echo "$first_line"
    fi
    cat -
}

do_rofi() {
    eval "$(popup_window.sh -e)"

    rofi -sort -columns 1 -l $LINES -yoffset $Y -width $W -dmenu -i -async-pre-read 0 -p "$prompt" -no-click-to-exit -location 2 "$(theme getval p_font_main | sed 's/-/ /')" |
	while IFS=$'\n' read -r rofi_line; do
	    echo "$rofi_line"
	    if [ ! -z "$FEEDER_PID" ]; then
		kill -- -$(ps -o pgid= $FEEDER_PID | grep -o [0-9]*)
		# kill -- $FEEDER_PID
	    fi
	    break;
	done
}

if elisp t >/dev/null; then
    . ~/.sh.d/environment
    if $MAC; then
	find_class emacs
    fi

    result=$(read_input | emacs_dmenu "$prompt")
elif type rofi >/dev/null; then
    result=$(read_input | do_rofi)
else
    result=$(read_input | og dmenu -p "$prompt")
fi

if [ -z "$result" ]; then
    echo
    exit 1
else
    echo "$result"
    exit 0
fi
