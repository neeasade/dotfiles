#!/usr/bin/env bb
;; do things with mpd
;; todo: better cue file support
;; todo: remove by hash for there be duplicates

;; todo idea: mpd-stats: generate stats for songs and artists
;; - print artists with n minutes of content

(require '[babashka.pods :as pods])

(pods/load-pod 'org.babashka/buddy "0.3.4")

(require '[babashka.fs :as fs]
         '[clojure.java.io :as io]
         '[clojure.java.shell :as shell]
         '[clojure.string :as string]
         '[pod.babashka.buddy.hash :as hash]
         '[pod.babashka.buddy.codecs :as c])

(def cache-map
  (->> (string/split (slurp "/home/neeasade/.config/mpd/database")
                     #"song_begin:")
       (remove nil?)
       (remove #(= "" (string/trim %)))
       (keep (fn [song-chunk]
               (let [lines (string/split-lines song-chunk)
                     title (string/trim (first lines))
                     duration (first (filter #(string/starts-with? % "Time:") lines))
                     duration (when duration
                                (read-string (second (string/split duration #":"))))]
                 (when duration
                   {title duration}))))
       (into {})))

(defn mpc [& args]
  (let [result (apply shell/sh "mpc" args)]
    (when (and (:err result) (not (string/blank? (:err result))))
      (.println *err* (str "mpc error: " (:err result))))
    (string/split-lines (:out result))))

(defn file-hash [f]
  ;; still messing around with speed here
  (when (fs/exists? f)
    (first
     (string/split
      (:out
       (shell/sh "sha256sum"
                 f
                 ))
      #" "))))

(defn file-hashdedup []
  (->> (mpc "playlist" "-f" "%file%")
       (map (partial str "/home/neeasade/Music/"))
       (group-by file-hash)
       (map (fn [[k v]] (first v)))
       (run! println)))

(defn clear-duplicates
  ([] (clear-duplicates "manual"))
  ([op] (when (some #(= % op) ["artist" "playlist" "append" "manual"])
          (let [current (first (mpc "-f" "%position%"))
                duplicates (->> (mpc "playlist" "-f" "%position% %file%")
                                (map #(string/split % #" " 2))
                                (group-by second)
                                (keep (fn [[song pairs]]
                                        (when (> (count pairs) 1)
                                          (->> pairs
                                               (map first)
                                               (remove #(= current %))))))
                                (map (fn [positions]
                                       ;; complexity from the current position case
                                       (if (= 1 (count positions))
                                         positions
                                         (rest positions))))
                                (flatten))]
            (when-not (empty? duplicates)
              (println "clearing duplicates:" (string/join " " duplicates))
              (mpc "del" "--wait" :in (string/join "\n" duplicates)))))))

(defn is-long [song]
  (let [duration (or (get cache-map (fs/file-name song)) 0)]
    (> duration (* 60 15))))

(defn pomodoro-song-now []
  ;; todo: a way to do album length would be nice as well
  ;; would infer an album cache structure somewhere?
  ;; or maybe could make it from cache somehow (sum lengths)
  (mpc "clear")
  (->> (mpc "listall")
       (map fs/filename)
       (map (fn [song]
              {song (or (get cache-map song) 0)}))
       (into {})
       (filter (fn [[k v]]
                 ;; (< (* 60 23) v (* 60 28))
                 (< (* 60 23) v (* 60 25))))
       (shuffle)
       (first)
       (first)
       (shell/sh "music" "now")
       (:out)
       (println)))

(defn filter-meta [filter-fn]
  (let [delete-positions (->> (mpc "playlist" "-f" "%position% %file%")
                              (keep (fn [line]
                                      (let [[_ pos song] (first (re-seq #"([0-9]+) (.*)" line))]
                                        (when-not (filter-fn song)
                                          pos)))))]
    (mpc "del" :in (string/join "\n" delete-positions))))

(defn filter-is-long [] (filter-meta is-long))
(defn filter-is-short [] (filter-meta (complement is-long)))

(defn is-album-dir [[dir songs]]
  (let [indexed-pattern #"^([0-9]+)\..*"]
    (and
     ;; (< 3 (count songs))
     ;; (every? (complement is-long) songs) ; does this matter?
     (every? #(re-matches indexed-pattern (fs/file-name %)) songs)

     ;; kinda strict
     (let [numbers (sort (keep (fn [song]
                                 (when-let [match (re-matches indexed-pattern (fs/file-name song))]
                                   (read-string (string/replace (second match) #"^0+" ""))))
                               songs))]
       (= numbers (range (first numbers) (inc (count numbers)))))))) ; eric's idea

(defn shuffle-by-album
  ([] (shuffle-by-album is-album-dir))
  ([album-predicate]
   (->> (mpc "playlist" "-f" "%file%")
        (sort)
        (distinct)
        (group-by
         (fn [path]
           (->> (string/split path #"/")
                (drop-last)
                (string/join "/"))))
        (mapcat (fn [[dir songs]]
                  (if (album-predicate [dir songs])
                    [[dir songs]]
                    (map (fn [album] [dir [album]])
                         (filter is-long songs)))))
        (shuffle)
        (mapcat second))))

(defn shuffle-by-album-force []
  (shuffle-by-album (constantly true)))

(defn remove-pairs [s]
  (reduce
   (fn [s [a b]]
     (string/replace s
                     (re-pattern (format "%s[^%s]+%s"
                                         a
                                         (str (last b))
                                         b))
                     ""))
   s
   [["【" "】"]
    ["●" "●"]
    ["～" "～"]
    ["\\(" "\\)"]
    ["\\[" "\\]"]]))

(defn track-names [scope]
  ;; scope is {listall, playlist, or nil for only currently playing track}
  (->> (if scope
         (mpc scope "-f" "%artist%^%title%^%file%")
         (take 1 (mpc "-f" "%artist%^%title%^%file%")))
       (map #(string/split % #"\^"))
       (map (fn [[artist title filepath]]
              (cond
                (and (not (string/blank? artist))
                     (not (string/blank? title))) (if (string/includes? title artist)
                                                    title
                                                    (str artist " - " title))
                (not (string/blank? title)) title
                :else (-> filepath
                          (fs/file-name)
                          (fs/strip-ext)))))
       (map #(-> %
                 (remove-pairs)
                 (string/replace #"\-[0-9a-zA-Z_\-]{11}$" "")
                 (string/replace #"^[0-9]+\. " "")
                 (string/replace "＂" "\"")
                 (string/replace #"_" " ")
                 (string/replace "|" "-")
                 (string/replace "full album" "")
                 (string/replace " Full " "")
                 (string/replace #"[ ]+" " ")
                 (string/trim)
                 ((fn [s]
                    (if (and (not (Character/isLetter (last s)))
                             (= \space (first (take-last 2 s))))
                      (string/trim (apply str (drop-last 2 s)))
                      s)))))))

(defn display-context []
  (let [{:keys [complete empty sep]} (read-string (:out (apply shell/sh (string/split "theme -n mkb -f complete,empty,sep" #" "))))
        current (Integer/parseInt (first (mpc "-f" "%position%")))
        current (dec current)
        playlist (track-names "playlist")]
    (->> [-2 -1 0 1 2]
         (map (partial + current))
         (filter #(> % -1))
         (map (fn [index]
                (str (cond (> current index) complete
                           (< current index) empty
                           (= current index) sep)
                     " "
                     (nth playlist index)))))))

(defn format-length [length]
  (-> (list (int (-> length (/ 60) (/ 60)))
            (int (-> length (/ 60) (mod 60)))
            (int (mod length 60)))
      (interleave ["h " "m " "s"])
      (->> (apply str))))

(defn display-info []
  (->> (let [top (first (track-names nil))
             bottom (format "playlist: %s | %s"
                            (string/trim (slurp "/home/neeasade/Music/playlist/current"))
                            (->> (mpc "playlist")
                                 (map #(or (get cache-map (fs/file-name %)) 0))
                                 (apply +)
                                 (format-length)))
             percent (second (re-find #"([0-9]+)%" (second (mpc))))
             middle (:out (shell/sh "mkb" percent (->> (list top bottom)
                                                       (map count)
                                                       (sort)
                                                       (reverse)
                                                       (first)
                                                       (str))))]
         [top middle bottom])
       (map string/trim)
       (string/join "\n")
       (shell/sh "box" :in)
       (:out)))

(defn unused-songs []
  (let [playlist-songs (->> (fs/list-dir "/home/neeasade/.config/mpd/playlists" "*.m3u")
                            (map str)
                            (map slurp)
                            (string/join "\n")
                            string/split-lines
                            set)

        all-songs (set (mpc "listall"))]
    (set/difference all-songs playlist-songs)))

(let [cmd (or *command-line-args* ["shuffle-by-album"])
      result (apply (-> cmd first symbol resolve)
                    (rest cmd))]
  (cond
    (string? result) (print result)
    (and result (seqable? result)) (run! println result)))
