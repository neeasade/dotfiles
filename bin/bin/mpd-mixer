#!/usr/bin/env bb
;; do things with mpd
;; todo: better cue file support
;; todo: auto refresh is-long cache? (right now I just ran it once manually)
;; todo: more data per song? update seconds compare instead of boolean

(require '[clojure.java.shell :as shell]
         '[clojure.string :as string]
         '[babashka.fs :as fs])

(def music-dir "/home/neeasade/Music")

;; right now, cache is simply {"/song-path" <int> duration}
(def cache-file (fs/file (fs/xdg-cache-home) "mpd-info"))

(def cache-map (when (fs/exists? cache-file)
                 (read-string (slurp cache-file))))

(defn song-length [song]
  (let [length-str (:out (shell/sh "mediainfo" "--Inform=Audio;%Duration%" (str music-dir "/" song)))
        length-ms (if (string/blank? (string/trim length-str))
                    ;; (do (prn "oops!") 0)
                    0
                    (read-string length-str))]
    (/ length-ms 1000)))

(defn is-long [song]
  (let [duration (or (get cache-map song)
                     (song-length song))]
    (> duration (* 60 15))))

(defn mpc [& args] (string/split (:out (apply shell/sh "mpc" args)) #"\n"))

;; nb: this takes awhile (2 minutes ish?)
(defn refresh-cache []
  (->> (mpc "listall")
       (map (fn [song] {song (song-length song)}))
       (into {})
       (pr-str)
       (spit (str cache-file)))
  nil)

(defn pomodoro-song-now []
  ;; todo: a way to do album length would be nice as well
  ;; would infer an album cache structure somewhere?
  ;; or maybe could make it from cache somehow (sum lengths)
  (mpc "clear")
  (->> (mpc "listall")
       (map (fn [song]
              {song (or (get cache-map song) (song-length song))}))
       (into {})
       (filter (fn [[k v]]
                 (< (* 60 23) v (* 60 28))))
       (shuffle)
       (first)
       (first)
       (shell/sh "music" "now")
       (:out)
       (println)))

(defn filter-meta [filter-fn]
  (let [delete-positions (->> (mpc "playlist" "-f" "%position% %file%")
                              (keep (fn [line]
                                      (let [[_ pos song] (first (re-seq #"([0-9]+) (.*)" line))]
                                        (when-not (filter-fn song)
                                          pos)))))]
    (mpc "del" :in (string/join "\n" delete-positions))))

(defn filter-is-long [] (filter-meta is-long))
(defn filter-is-short [] (filter-meta (complement is-long)))

(defn shuffle-by-album []
  (->> (mpc "playlist" "-f" "%file%")
       (sort)
       (distinct)
       (group-by
        (fn [path]
          (->> (string/split path #"/")
               (drop-last)
               (string/join "/"))))
       ;; todo: bug: if a song is added but not an album, it will still be counted as one (we don't always add whole dirs)
       (mapcat (fn [[dir songs]]
                 (let [ ;; songs (filter )
                       is-indexed-album-strict? false
                       is-indexed-album? (and
                                          ;; (< 3 (count songs))
                                          (every? (complement is-long) songs) ; does this matter?
                                          (every? #(re-matches #"[0-9].+" (fs/file-name %)) songs)
                                          ;; todo: do all the numbers go up continuously/increment by one
                                          )
                       is-misc-album? (and ; idk man
                                       (< 4 (count songs) 17)
                                       (every? (complement is-long) songs))]
                   ;; todo: a way to toggle these from caller
                   (cond
                     is-indexed-album? [[dir songs]]
                     ;; is-misc-album? [[dir (into [] (sort-by #(fs/last-modified-time (str music-dir "/" %)) songs))]]
                     :else
                     (map (fn [album] [dir [album]])
                          (filter is-long songs))))))
       (shuffle)
       (mapcat second)
       (string/join "\n")
       (println)))

((->> (or *command-line-args* ["shuffle-by-album"])
      first
      symbol
      resolve))
