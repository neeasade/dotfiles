#!/bin/sh
# provide a way to run elisp in a running emacs-server
# can act as a shebang (ie #!/usr/bin/env elisp) or
# adhoc code (ie elisp '(message "uwu")')
# note: when args are passed to a shebang, they are available with the variable 'ns-args' as a list
# todo: getopt, a -q option for quiet
# todo: a way to connect in the current terminal and maybe edit a file from here

trim=false
if [ "$1" = "-r" ]; then
    trim=true
    shift
fi

if [ -f "$1" ]; then
    script_name=$(realpath "$1")
    shift
fi

eclient="emacsclient"
if uname | grep -qE '(MINGW|MSYS)'; then
    # windows
    eclient="${eclient}w --server-file ${HOME}/.emacs.d/server/${EMACS_SERVER_FILE:-emacs-server-file}"
fi

add_stdin() {
    # notify-send "getting stdin"

    # save stdin to a file and give a var
    # todo: this is blocking, and if we continue down this path it may be worth looking into input streams
    # note: it's important to only do this in script mode, else any elisp call will slurp up stdin
    if [ -p /dev/stdin ]; then
	if [ -d /dev/shm/ ]; then
	    stdin_file=/dev/shm/elisp-${RANDOM}
	else
	    stdin_file=$(mktemp)
	fi

	cat - > "$stdin_file"
    fi
}

if [ -z "$script_name" ]; then
    elisp_timeout=${elisp_timeout:-1}
    lisp="(progn $@)"
    if [ ! -z "$FORCE_STDIN" ]; then
	add_stdin
	if [ ! -z "$stdin_file" ]; then
	    lisp="(let ((*stdin-file* \"${stdin_file}\")) ${lisp})"
	fi
    fi
else
    trim=true
    elisp_timeout=${elisp_timeout:-15} # arbitrary

    # shell -> elisp
    args=
    for a in "$@"; do
	args="${args} \\\"${a}\\\""
    done
    args="(${args})"

    script_name="\"${script_name}\""

    add_stdin

    if [ -z "$stdin_file" ]; then
	stdin_file=nil
    else
	stdin_file="\"${stdin_file}\""
    fi

    lisp="(->> ${script_name} f-read (format \"(let ((*stdin-file* ${stdin_file}) (ns-args '${args})) %s)\") read eval)"
fi

emacs_timeout=
if type timeout >/dev/null; then
    emacs_timeout="timeout ${elisp_timeout}"
fi

# echo $emacs_timeout $eclient --eval "$lisp"
result=$($emacs_timeout $eclient --eval "$lisp")

quit() {
    if [ ! -z "$stdin_file" ]; then
	if [ ! "$stdin_file" = "nil" ]; then
	    rm "$stdin_file"
	fi
    fi

    exit ${*:-1}
}

if [ $? -eq 1 ]; then
    # we could not reach emacs, or we timed out.

    # if we were running a script, try to save by defaulting to last arg
    if [ ! -z "$script_name" ]; then
	while [ ! -z "$*" ]; do
	    last=$1
	    shift
	done
	echo "$last"
    fi

    quit 1
fi

if [ "$result" = "nil" ] || [ -z "$result" ]; then
    quit 1
fi

if $trim; then
    case "$result" in
	# (1 2 3) -> # 1 2 3
	"("*) result=${result:1:${#result}-2}; echo "$result";;
	# "\"~/.dotfiles/bin/bin/elisp\n~/.emacs.d/recentf\""
	#     -> "~/.dotfiles/bin/bin/elisp$'\n'~/.emacs.d/recentf"
	'"'*) result=${result:1:${#result}-2}
	      result=$(echo "$result" | sed 's/%/%%/g')
	      # replace
	      printf "$result"
	      echo
	      ;;
	# just print it
	*) echo "$result" ;;
    esac
else
    echo "$result"
fi

quit 0
