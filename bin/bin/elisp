#!/bin/sh
# provide a way to run elisp in a running emacs-server
# can act as a shebang (ie #!/usr/bin/env elisp) or
# adhoc code (ie elisp '(message "uwu")')
# todo: getopt, a -q option for quiet

trim=false
if [ "$1" = "-r" ]; then
    trim=true
    shift
fi

if [ -f "$1" ]; then
    script_name=$(realpath "$1")
    shift
fi

eclient="emacsclient"
if [ ! -z "$(uname | awk '$1 ~ /MINGW|MSYS/ {print $1}')" ]; then
    # windows
    eclient="${eclient}w --server-file ${HOME}/.emacs.d/server/${EMACS_SERVER_FILE:-emacs-server-file}"
fi

add_stdin() {
    # notify-send "getting stdin"

    # save stdin to a file and give a var
    # todo: this is blocking, and if we continue down this path it may be worth looking into input streams
    # note: it's important to only do this in script mode, else any elisp call will slurp up stdin
    if [ -p /dev/stdin ]; then
	if [ -d /dev/shm/ ]; then
	    stdin_file=/dev/shm/elisp-${RANDOM}
	else
	    stdin_file=$(mktemp)
	fi

	cat - > "$stdin_file"
	lisp="(let ((*stdin-file* \"${stdin_file}\")) ${lisp} )"
    fi
}

if [ -z "$script_name" ]; then
    elisp_timeout=${elisp_timeout:-1}
    lisp="(progn $@)"
    if [ ! -z "$FORCE_STDIN" ]; then
	add_stdin
    fi
else
    trim=true
    elisp_timeout=${elisp_timeout:-15} # arbitrary

    args=
    for a in "$@"; do
	args="${args} \"${a}\""
    done

    # todo: if the script_name contains a '(provide)' consider just loading rather than eval-file
    lisp="(ns/eval-file \"${script_name}\" ${args})"

    add_stdin
fi

emacs_timeout=
if type timeout >/dev/null; then
    emacs_timeout="timeout ${elisp_timeout}"
fi

result=$($emacs_timeout $eclient --eval "$lisp")

quit() {
    if [ ! -z "$stdin_file" ]; then
	rm "$stdin_file"
    fi

    exit ${*:-1}
}

if [ $? -eq 1 ]; then
    # we could not reach emacs, or we timed out.

    # if we were running a script, try to save by defaulting to last arg
    if [ ! -z "$script_name" ]; then
	while [ ! -z "$*" ]; do
	    last=$1
	    shift
	done
	echo "$last"
    fi

    quit 1
fi

if [ "$result" = "nil" ] || [ -z "$result" ]; then
    quit 1
fi

if $trim; then
    case "$result" in
	# (1 2 3) -> # 1 2 3
	"("*) result=${result:1:${#result}-2}; echo "$result";;
	# "\"~/.dotfiles/bin/bin/elisp\n~/.emacs.d/recentf\""
	#     -> "~/.dotfiles/bin/bin/elisp$'\n'~/.emacs.d/recentf"
	'"'*) result=${result:1:${#result}-2}
	      result=$(echo "$result" | sed 's/%/%%/g')
	      # replace
	      printf "$result"
	      echo
	      ;;
	# just print it
	*) echo "$result" ;;
    esac
else
    echo "$result"
fi

quit 0
