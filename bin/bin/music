#!/usr/bin/env bash
# this is by far my favorite script to tinker with
# https://notes.neeasade.net/search-term-playlists.html
# duties:
# - wrap the importing of music from the internet
# - define music playlists by search terms
# - add a neat display func
# - some helpers to manage your local music

# musicdir="$HOME/Music"
musicdir=$(awk -F\" '/music_directory/{print $2}' "$HOME/.config/mpd/mpd.conf")
current_playlist="${musicdir}/playlist/current"

### HELPERS/MAINT
log() {
  printf '%s\n' "$*"
  notify-send -u low "$*"
}

usage() {
  echo "music options:"
  awk -F \# '{ if (match($0, /([a-z]+)\(\) {.*#/, line)) { printf "%-9s:%s\n", line[1], $2 }}' "$0" | sort
}

is_long() {
  milli=$(mediainfo --Inform="Audio;%Duration%" "$1")
  milli=${milli%.*}

  if [ -z "$milli" ]; then
    return 1
  fi

  seconds=$(( $milli / 1000))
  if [ $seconds -gt $((60 * 15)) ]; then
    return 0
  else
    return 1
  fi
}

is_short () {
  ! is_long "$@"
}

filter() { # filter the current playlist by some shell function acting on music files
  log "filter $*"

  fn=$1
  mpc playlist -f '%position% %file%' |
    while read -r pos file; do
      if ! "$fn" "${musicdir}/$file" "$pos" >/dev/null; then
	echo "$pos"
      fi
    done | mpc del
}

clear_duplicates() {
  duplicates_exist() {
    duplicates=$(mpc playlist -f '%position% %file%' | sort -k2 | tac | uniq -f1 -d | sed 's/ .*//')
    ! test -z "$duplicates"
  }

  while duplicates_exist; do
    mpc del --wait <<< "$duplicates"
  done
}

### ACTIONS

stay() { # do some action, but keep the current song and position
  test -z "$*" && return
  state_song=$(mpc -f "%file%" | head -n 1)
  state_progress=$(mpc -f '%file%' | awk -F '[ /]*' '/playing/{print $4}')
  "$@"
  now "$state_song"
  cur_pos=$(mpc -f "%position%" | head -n 1)
  mpc mv $cur_pos $((cur_pos - 1))
  mpc prev
  mpc seek "+$state_progress"
}

add() { # add a url to library, fallback on clipboard content
  url=$*
  [ -z "$url" ] && url=$(xclip -o -selection clipboard)
  mkdir -p "$musicdir/import"

  # note: get all of an artists album links example:
  example() {
    url='https://shigeto.bandcamp.com/music'
    curl "$url" | pup a attr{href} | awk "/\/album/" | sed -e "s#^#music add '$(echo "$url" | sed 's/music//')#" -e "s/$/'/"
  }

  if [[ $url =~ youtube.com ]]; then
    format="$musicdir/import/%(uploader)s/%(title)s.%(ext)s"
  else
    # usually bandcamp -- we want track_number for album song order sorting
    format="$musicdir/import/bandcamp/%(uploader)s/%(album)s/%(track_number)02d. %(title)s.%(ext)s"
  fi

  youtube-dl --download-archive  "$musicdir/download_archive.txt" -x -i -o "$format" "$url"

  mpc update
}

del() { # delete the currently playing song
  read -r location <<< $(mpc -f '%file%')
  rm "$musicdir/$location"
  mpc next
  mpc update
}

append() { # append some search term to the current playlist
  echo append "$*"

  if [ -z "$songs_cached" ]; then
     songs_cached=$(mpc listall)
  fi

  grep -i $GREP_EXTRA "$*" <<< "$songs_cached" | mpc add --wait

  if [ "$interactive_op" = "append" ]; then
    # we called append at an interactive level, therefore we are no longer tied to any playlist
    echo "custom" > "$current_playlist"

    clear_duplicates
  fi
}

remove() { # remove some search match from the playlist
  echo remove "$*"
  mpc playlist -f '%position% %file%' | grep -i $GREP_EXTRA "$*" | sed 's/ .*//' | mpc del
}

now() { # fuzzy search for a song, play it now
  if [ -z "$*" ]; then
    if ! song=$(mpc listall | dmenu "song"); then
       return
    fi
  else
    song=$*
  fi

  mpc insert "$song"
  mpc next
  mpc play
  # echo "custom" > "$current_playlist"
}

bl() { # blacklist the currently playing song from the current playlist.
  playlist=$(cat "$current_playlist")
  songname=$(basename "$(mpc -f '%file%' | head -n 1)")
  songname=$(sed "s#'#\'\\\\\'\'#g" <<< "$songname")
  printf "\n- '${songname}'" >> "$musicdir/playlist/$playlist"
  mpc next
}

artist() { # play songs by an artist
  artist=$*
  if [ -z "$artist" ]; then
    if ! artist=$({
		   mpc listall -f '%artist%' | grep -v '^$' | tr '[:upper:]' '[:lower:]'
		   cat "${musicdir}/playlist/artists"
		   ls "${musicdir}/import/bandcamp/"
		 } | sort | uniq | dmenu); then
      return
    fi
  fi

  log "artist $artist"

  if [ "$interactive_op" = "artist" ]; then
    echo "$artist" > "$current_playlist"
    mpc clear
  fi

  {
    append "/${artist} "
    append "/${artist}/"
    append "/${artist}[ ]\+[-(]"
    append "\. ${artist}[ ]\+[-(]"
    append "\- ${artist}\(\..*\)\?$"
  } >/dev/null

  # correct casing for exact matches from the above
  mpc listall -f '%artist%' | grep -i "^${artist}$" | \
    while read corrected; do
      mpc find artist "$corrected" | mpc add --wait
    done

  if [ "$interactive_op" = "artist" ]; then
    clear_duplicates

    if ${SHUFFLE:-true}; then
      # shuffle_preserve_album
      # no_long_filter
      mpc shuffle
    fi

    mpc play
  fi
}

artist_append() {
  # interactive op redir
  artist "$@"
}

playlist() { # select a search term based playlist to play
  if [ -z "$1" ]; then
    if ! target=$(ls "${musicdir}/playlist" | dmenu); then
      return
    fi
  else
    target=$*
  fi

  mpc clear
  echo "$target" >"$current_playlist"
  loaded_cached_playlist=false

  # Check if we can use the cached playlist
  # <2021-11-22 Mon 10:09> this has been tested and works as expected.
  mpd_database="$HOME/.config/mpd/database"
  mpd_playlist="$HOME/.config/mpd/playlists/${target}.m3u"
  music_playlist="$musicdir/playlist/${target}"
  if ! grep -i shuffle "$music_playlist"; then
    if [ -s "$mpd_playlist" ]; then
      if [ "$mpd_playlist" -nt "$music_playlist" ]; then
	if [ "$mpd_playlist" -nt "$mpd_database" ]; then
	  echo "loading cached playlist $mpd_playlist"
	  cat "$mpd_playlist" | mpc add
	  loaded_cached_playlist=true
	fi
      fi
    fi
  fi

  # let's get really dumb, DSL through character functions
  + () { append "$@"; }
  - () { remove "$@"; }
  @ () { artist "$@"; }

  if $loaded_cached_playlist; then
    # this lets us preserve SHUFFLE directives and other custom junk
    append () { silent; }
    remove () { silent; }
    artist () { silent; }
    filter() { silent; }
  fi

  . "$music_playlist"

  clear_duplicates
  if ${SHUFFLE:-true}; then
    mpc shuffle
  fi
  mpc play

  mpc rm "$target"
  mpc save "$target"
}

# mpc only
name_from_pos() {
  pos=$1
  if [ -z "$pos" ]; then
    pos=$(mpc -f '%position%' | head -n 1)
  fi

  IFS=^ read title artist < <(mpc playlist -f '%title%^%artist%' | awk "NR==${pos}")
  if test -z "$title" || test -z "$artist"; then
    name=$(basename "$(mpc playlist -f '%file%' | awk "NR==${pos}")")
    name=${name%.*}
  else
    name="$title - $artist"
  fi

  # ASSUME
  if grep -qE '\-[0-9a-zA-Z_\-]{11}$' <<< "$name" ; then
    name=${name::-12}
  fi

  clean_name
}

clean_name() {
  # operates on an already set $name var
  remove_delim() {
    # maybe
    # name=$(sed "s/${1}[^${1: -1}${2: -1}]*${2}//g" <<< "$name")
    name=$(sed "s/${1}\(.*\)${2}//g" <<< "$name")
  }

  remove_delim '(' ')'
  remove_delim '\[' '\]'
  remove_delim '【' '】'
  remove_delim '●' '●'

  case "$name" in
      # track index
      [0-9][0-9].*) name=${name:4} ;;
  esac

  # todo: this better? want ^[0-9]{4} $
  # name=${name// [0-9][0-9][0-9][0-9] / }

  name=${name/full album}
  name=${name//_/ }
  name=${name//  / }
  name=${name//  / }
  name=${name/|/-}
  name=${name/▶︎ /}
  name=${name%% - }

  trim_string() {
    # ugh
    : "${1#"${1%%[![:space:]]*}"}"
    : "${_%"${_##*[![:space:]]}"}"
    printf '%s\n' "$_"
  }

  trim_string "$name"
}

gather_playerctl_info() {
  percent=$((RANDOM%100))

  IFS=^ read length name from < <(player.sh -f '{{mpris:length}}^%title%^%artist%')
  case "$name" in
      # bandcamp specific thingy for artists under a label:
      "▶︎ "*|*|*)
	  IFS=\| read title artist from < <(echo "$name")
	  name="${title} - ${artist}"
	  ;;
  esac

  if ! test -z "$length"; then
    p_position=$(playerctl position)
    percent=$(bc <<< "($p_position * 100) / ($length / 1000000)")
  fi
  if ! test -z "$from"; then
    if ! grep -qi "$from" <<< "$name"; then
      from=$(name=$from clean_name)
      bottom_line="from: $from"
    fi
  fi

  name=$(clean_name)
}

info() { # display the current audio progress bar and playlist length
  if [ "$(GET=t player.sh)" = "playerctl" ]; then
    gather_playerctl_info
  else
    name=$(name_from_pos)
    percent=$(mpc | awk -F '[(%]' 'NR==2{print $2}')
    bottom_line=$(printf "playlist: %s | %s" "$(cat "$current_playlist")" "$(playlist_length)")
  fi

  w_progress=${#name}
  if (( ${#bottom_line} > ${#name})); then
    w_progress=${#bottom_line}
  fi

  pad_left=$(( ${#name} / 2 + ${#bottom_line} / 2 ))
  align_print() {
    line=$*
    add=$(( $(wc -c <<< "$line") - ${#line} ))
    printf "%$((pad_left + add))s\n" "$line"
  }

  align_print "$name"
  mkb "${percent/.*/}" $w_progress
  test -z "$bottom_line" || align_print "$bottom_line"
}

info2() {
  echo "  >> playlist: $(cat $current_playlist) | $(playlist_length) <<"
  context
}

shuffle_preserve_album() {
  log shuffle_preserve_album
  SHUFFLE=false # prevent playlists with this in their definition from shuffling
  shuffled=$(mpd_shuffle)
  mpc clear
  mpc add <<< "$shuffled"
  mpc play
}

context() {
  pos=$(mpc -f '%position%' | head -n 1)
  start=$((pos - 2))
  if [ $start -lt 1 ]; then
    start=1
  fi
  end=$((pos + 2))

  eval "$(theme -n mkb -f "complete,empty,sep" -s)"

  mpc playlist -f '%position%' | awk " {
if (NR>=${start} && NR<=$end)
    {if (NR==${pos})
{ print \"${sep} \" \$0}
else if (NR<${pos})
{ print \"${complete} \" \$0}
else if (NR>${pos})
{ print \"${empty} \" \$0}
    }} " | while read -r prefix pos; do
  echo "$prefix $(name_from_pos $pos)"
  done
}

interactive_op=${1:-usage}
shift
$interactive_op "$@"
