#!/usr/bin/env bash
# https://notes.neeasade.net/search-term-playlists.html
# duties:
# - wrap the importing of music from the internet
# - define music playlists by search terms
# - add a neat display func
# - some helpers to manage your local music

# todo: some way to keep album song collections together/distinguish them as a mix/keep them together

# musicdir="$HOME/Music"
musicdir=$(awk -F\" '/music_directory/{print $2}' "$HOME/.config/mpd/mpd.conf")
current_playlist="${musicdir}/playlist/current"

### HELPERS/MAINT

usage() {
  echo "music options:"
  grep -E "^[A-Za-z_]+\(\) {.*#" "$0" | sed 's/() {//' | sort | while read -r line; do
    action=$(sed 's/ #.*//' <<< "$line" )
    desc=$(sed 's/.*# //' <<< "$line" )
    printf "%-10s : %s\n" "$action" "$desc"
  done
  exit 1
}

count() {
    printf '%s\n' "$#"
}

is_album_song() {
  file=$1

  if [[ $file =~ bandcamp ]]; then
    return 0
  fi

  count=$(count "$(dirname "$file")"/*)
  # these numbers were chosen arbitrarily.
  if [ $count -lt 15 ]; then
    if [ $count -gt 4 ]; then
      return 0
    fi
  fi

  return 1
}

is_long() {
  milli=$(mediainfo --Inform="Audio;%Duration%" "$*" | sed 's/\..*//')
  if [ -z "$milli" ]; then
    return 1
  fi

  seconds=$(( $milli / 1000))
  if [ $seconds -gt $((60 * 15)) ]; then
    return 0
  else
    # is_album_song
    return 1
  fi
}

is_short () {
  ! is_long "$@"
}

filter() { # filter the current playlist by some shell function acting on music files
  echo "filter $*"
  fn=$1
  mpc playlist -f '%position% %file%' |
    while read -r pos file; do
      if ! $fn "${musicdir}/$file" >/dev/null; then
	echo "$pos"
      fi
    done | mpc del
}

clear_duplicates() {
  duplicates_exist() {
    duplicates=$(mpc playlist -f '%position% %file%' | sort -k2 | uniq -f1 -d | sed 's/ .*//')
    ! test -z "$duplicates"
  }

  while duplicates_exist; do
    mpc del <<< "$duplicates"
  done
}

### ACTIONS

add() { # add a url to library, fallback on clipboard content
  url=$*
  [ -z "$url" ] && url=$(xclip -o -selection clipboard)
  mkdir -p "$musicdir/import"

  # note: get all of an artists album links example:
  # url='https://sewerslvt.bandcamp.com/'
  # curl "$url" | pup a attr{href} | awk "/\/album/" | sed -e "s#^#music add '${url}#" -e "s/$/'/"

  if [[ $url =~ bandcamp.com ]]; then
    # bandcamp music is organized by album:
    format="$musicdir/import/bandcamp/%(uploader)s/%(album)s/%(title)s.%(ext)s"
  else
    format="$musicdir/import/%(uploader)s/%(title)s.%(ext)s"
  fi

  # break things out by song url, so we can report statuses individually for later cleanup
  # this is sort of a wonky way to do things (new process per song url)
  # TODO: checkout --print-json (download but still print json)
  youtube-dl -x -i -j -o "$format" "$url" | jq -r '.webpage_url + " " + .title' | \
    while read narrow_url title; do
	# remove previous status entries for this url
	sed -i "\^|${narrow_url}|^d" "$musicdir/import_history.log"

	if youtube-dl -x -i -o "$format" "$narrow_url"; then
	  result=success
	else
	  result=fail
	fi

	printf "\n|%s|%s|%s|%s|\n" "$narrow_url" "$title" "$(date)" "$result" >> "$musicdir/import_history.log"
    done

  sed -i '/^$/d' "$musicdir/import_history.log"
  echo >> "$musicdir/import_history.log"

  mpc update # re-index
}

del() { # delete the currently playing song
  read -r location <<< $(mpc -f '%file%')
  rm "$musicdir/$location"
  mpc next
  mpc update
}

shuffle() { # reshuffle current selection from all
  mpc clear
  mpc listall | sort -R | head -n 1000 | mpc add
  echo "shuffle $*" > "$current_playlist"
  mpc play
}

append() { # append some search term to the current playlist
  echo append "$*"

  if [ "$interactive_op" = "append" ]; then
      # we called append at an interative level, therefore we are no longer tied to any playlist
      echo "custom" > "$current_playlist"
  fi

  if [ -z "$songs_cached" ]; then
     songs_cached=$(mpc listall)
  fi

  grep -i $GREP_EXTRA "$*" <<< "$songs_cached" | mpc add
}

remove() { # remove some search match from the playlist
  echo remove "$*"
  mpc playlist -f '%position% %file%' | grep -i $GREP_EXTRA "$*" | sed 's/ .*//' | mpc del
}

now() { # fuzzy search for a song, play it now
  if song=$(mpc listall | dmenu "song"); then
    mpc insert "$song"
    mpc next
    mpc play
    # echo "custom" > "$current_playlist"
  fi
}

bl() { # blacklist the currently playing song from the current playlist.
  playlist=$(cat "$current_playlist")
  songname=$(basename "$(mpc -f '%file%' | head -n 1)")
  songname=$(sed "s#'#\'\\\'\'#g" <<< "$songname")
  printf "\n- '${songname}'" >> "$musicdir/playlist/$playlist"
  mpc next
}

artist() { # play songs by an artist
  artist=$*
  if [ -z "$artist" ]; then
    if ! artist=$({
		   mpc listall -f '%artist%' | grep -v '^$' | tr '[:upper:]' '[:lower:]' | sort | uniq
		   cat "${HOME}/Music/playlist/artists"
		 } | dmenu); then
      return
    fi
  fi

  echo "artist $artist"

  if [ "$interactive_op" = "artist" ]; then
    echo "$artist" > "$current_playlist"
    mpc clear
  fi

  {
    append "/${artist} "
    append "/${artist}/"
    append "/${artist}[ ]\+[-(]"
    append "\- ${artist}\(\..*\)\?$"
  } >/dev/null

  # correct casing for exact matches from the above
  mpc listall -f '%artist%' | grep -i "^${artist}$" | \
    while read corrected; do
      mpc find artist "$corrected" | mpc add
    done

  if [ "$interactive_op" = "artist" ]; then
    clear_duplicates
    if ${SHUFFLE:-true}; then
      mpc shuffle
    fi
    mpc play
  fi
}

playlist() { # select a search term based playlist to play
  if [ -z "$1" ]; then
    if ! target=$(ls "${musicdir}/playlist" | dmenu); then
      return
    fi
  else
    target=$*
  fi

  mpc clear
  echo "$target" >"$current_playlist"

  # Check if we can use the cached playlist
  # <2021-11-22 Mon 10:09> this has been tested and works as expected.
  mpd_database="$HOME/.config/mpd/database"
  mpd_playlist="$HOME/.config/mpd/playlists/${target}.m3u"
  music_playlist="$musicdir/playlist/${target}"
  if [ -s "$mpd_playlist" ]; then
    if [ "$mpd_playlist" -nt "$music_playlist" ]; then
      if [ "$mpd_playlist" -nt "$mpd_database" ]; then
	echo "loading cached playlist $mpd_playlist"
	cat "$mpd_playlist" | mpc add
	# this shuffle is problematic -- how can you know if og playlist wanted it
	mpc shuffle
	mpc play
	return
      fi
    fi
  fi

  # let's get really dumb, DSL through character functions
  + () { append "$@"; }
  - () { remove "$@"; }
  @ () { artist "$@"; }
  . "$music_playlist"

  clear_duplicates
  if ${SHUFFLE:-true}; then
    mpc shuffle
  fi
  mpc play

  mpc rm "$target"
  mpc save "$target"
}

infoname() {
  name=$(player.sh -f '%title% - %artist%' | head -n 1)
  if [ "$name" = ' - ' ]; then
    name=$(basename "$(mpc -f '%file%' | head -n 1)")
    name=${name%.*}
  fi
  echo "$name"
}

info() { # display the current audio progress bar and playlist length
  infoname

  length=$(wc -L <<< "$name")
  # length=$(wc -c <<< "$name")

  if [ "$(GET=t player.sh)" = "playerctl" ]; then
      # we can't get the percent from playerctl, fake it for the looks
      # cf https://bytefreaks.net/gnulinux/bash/bash-get-random-number-that-belongs-in-a-range
      bottom=40
      top=80
      range=$((top-bottom+1))

      percent=$RANDOM
      let "percent %= $range"
      percent=$((percent+bottom))
  else
      percent=$(mpc | awk 'match($0,/\(([0-9]+)%\)/, groups) {print groups[1]}')
  fi

  mkb $percent $length

  if [ "$(GET=t player.sh)" = "mpc" ]; then
      echo "playlist: $(cat $current_playlist) | $(playlist_length)"
  fi
}

interactive_op=${1:-usage}
shift
$interactive_op "$@"
