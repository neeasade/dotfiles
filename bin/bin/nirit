#!/usr/bin/env bb
;; niri things
;; https://github.com/YaLTeR/niri/

(ns irit
  (:require [babashka.fs :as fs]
            [babashka.process :as process]
            [clojure.java.shell :as shell]
            [clojure.string :as string]
            [clojure.java.io :as io]
            [cheshire.core :as json]
            [lib.util :as lib]))

;; niri msg *
;; outputs windows keyboard-layouts focused-window pick-color output version overview-state
;; workspaces layers focused-output pick-window action event-stream request-error help
(defn msg [kind]
  (json/parse-string (lib/shh (str "niri msg --json " (name kind))) true))

(comment
  (msg "windows")
  )

;; center-column                         center-visible-columns           center-window                   clear-dynamic-cast-target                close-overview                close-window                     consume-or-expel-window-left
;; consume-or-expel-window-right         consume-window-into-column       debug-toggle-damage             debug-toggle-opaque-regions              do-screen-transition          expand-column-to-available-width expel-window-from-column
;; focus-column                          focus-column-first               focus-column-last               focus-column-left                        focus-column-left-or-last     focus-column-right               focus-column-right-or-first
;; focus-floating                        focus-tiling                     focus-window                    focus-window-bottom                      focus-window-down             focus-window-down-or-column-left focus-window-down-or-column-right
;; focus-window-down-or-top              focus-window-in-column           focus-window-or-workspace-down  focus-window-or-workspace-up             focus-window-previous         focus-window-top                 focus-window-up
;; focus-window-up-or-bottom             focus-window-up-or-column-left   focus-window-up-or-column-right focus-workspace                          focus-workspace-down          focus-workspace-previous         focus-workspace-up
;; fullscreen-window                     load-config-file                 maximize-column                 maximize-window-to-edges                 move-column-left              move-column-right                move-column-to-first
;; move-column-to-index                  move-column-to-last              move-column-to-workspace        move-column-to-workspace-down            move-column-to-workspace-up   move-floating-window             move-window-down
;; move-window-down-or-to-workspace-down move-window-to-floating          move-window-to-tiling           move-window-to-workspace                 move-window-to-workspace-down move-window-to-workspace-up      move-window-up
;; move-window-up-or-to-workspace-up     move-workspace-down              move-workspace-to-index         move-workspace-up                        open-overview                 power-off-monitors               power-on-monitors
;; reset-window-height                   screenshot                       screenshot-screen               screenshot-window                        set-column-display            set-column-width                 set-dynamic-cast-monitor
;; set-dynamic-cast-window               set-window-height                set-window-urgent               set-window-width                         set-workspace-name            show-hotkey-overlay              spawn
;; spawn-sh                              swap-window-left                 swap-window-right               switch-focus-between-floating-and-tiling switch-layout                 switch-preset-column-width       switch-preset-column-width-back
;; switch-preset-window-height           switch-preset-window-height-back switch-preset-window-width      switch-preset-window-width-back          toggle-column-tabbed-display  toggle-debug-tint                toggle-keyboard-shortcuts-inhibit
;; toggle-overview                       toggle-window-floating           toggle-window-rule-opacity      toggle-window-urgent                     toggle-windowed-fullscreen    unset-window-urgent              unset-workspace-name
(defn action [command & args]
  ;; debug
  ;; (prn action command)

  (apply lib/shh "niri" "msg" "action" (name command) (map str args))
  ;; (string/join " " (concat ["niri" "msg" "action" (name command)] (map str args)))
  )

(comment
  ;; (action "set-column-width" 50)
  (action :consume-or-expel-window-right)

  )

(defn find-class [class]
  ;; find or rotate windows by class/"App id"
  (let [data (msg :windows)
        active-window (->> data (filter :is_focused) first)
        active-wid (:id active-window)
        wids (keep (fn [w]
                     (when (and
                            (= class (last (string/split (:app_id w) #"\.")))
                            ;; scope to current workspace
                            (= (:workspace_id active-window) (:workspace_id w)))
                       (:id w)))
                   data)
        wids (concat wids [(first wids)])
        next-wid (if ((set wids) active-wid)
                   (let [i (.indexOf wids active-wid)]
                     (nth wids (inc i)))
                   (first wids))]
    (action :focus-window "--id" next-wid)))

(defn find-class-current []
  (find-class (:app_id (msg :focused-window))))

(defn maximized?
  ([] (maximized? (msg :focused-window)))
  ([window]
   (let [[mon-w mon-h] ((juxt :width :height) (:logical (second (first (msg :outputs)))))
         [win-w win-h] (:tile_size (:layout window))]
     (and
      (> win-w (* 0.8 mon-w))
      (> win-h (* 0.8 mon-h))))))

(defn tabbed? [window-id]
  ;; Check if a window is in a tabbed layout by comparing window sizes in the same column
  (let [windows (msg :windows)
        target-window (first (filter #(= window-id (:id %)) windows))]
    (when target-window
      (let [target-pos (first (get-in target-window [:layout :pos_in_scrolling_layout]))
            target-workspace (:workspace_id target-window)
            same-column-windows (filter #(and (= target-workspace (:workspace_id %))
                                              (= target-pos (first (get-in % [:layout :pos_in_scrolling_layout]))))
                                        windows)
            window-sizes (map #(get-in % [:layout :window_size]) same-column-windows)]
        ;; Windows are tabbed if there's more than one window and they all have the same size
        (and (> (count same-column-windows) 1)
             (apply = window-sizes))))))

(defn go-dir [dir]
  (let [win (msg :focused-window)
        term? (= "Alacritty" (:app_id win))
        elisp (format "(when-let (win (and (frame-focus-state) (window-in-direction '%s))) (select-window win))" dir)
        niri-move (condp = dir
                    "left" (fn [] (action "focus-window-up-or-column-left"))
                    "right" (fn [] (action "focus-window-down-or-column-right"))
                    "up" (fn [] (if (tabbed? (:id win))
                                  (action "focus-workspace-up")
                                  (action "focus-window-or-workspace-up")))
                    "down" (fn [] (if (tabbed? (:id win))
                                    (action "focus-workspace-down")
                                    (action "focus-window-or-workspace-down"))))]
    (if term?
      (when (= 1 (:exit (shell/sh "elisp" "-t" "1" elisp)))
        (niri-move))
      (niri-move))))

(defn switch-preset-width-and-center []
  (action :switch-preset-window-width)
  (Thread/sleep 50)

  ;; todo: diffent action for this
  ;; (when-not (maximized?)
  ;;   (action :focus-column-left)
  ;;   (action :focus-column-right))

  (action :center-window)
  )

(defn maximize-column []
  (if (maximized?)
    (do
      (action :maximize-column)
      ;; (action :maximize-window-to-edges)
      (Thread/sleep 50)

      ;; if the left column will fit, scroll
      (action :focus-column-left)
      (action :focus-column-right)
      ;; (action :center-window)
      )

    ;; (action :maximize-window-to-edges)
    (action :maximize-column)
    ))

(defn toggle-monocle-mode [width]
  ;; Toggle between tabbed single column and multiple columns
  (let [windows (msg :windows)
        current-window (msg :focused-window)
        current-id (:id current-window)
        workspace-id (:workspace_id current-window)
        workspace-windows (filter #(= workspace-id (:workspace_id %)) windows)]
    
    (when (> (count workspace-windows) 1)
      (let [column-positions (map #(first (get-in % [:layout :pos_in_scrolling_layout])) 
                                  workspace-windows)
            unique-columns (count (distinct column-positions))
            all-tabbed? (= 1 unique-columns)]
        
        (if all-tabbed?
          ;; Expel all windows from the tabbed column
          (do
            (action :toggle-column-tabbed-display)
            (action :focus-window-top)
            (dotimes [_ (dec (count workspace-windows))]
              (action :expel-window-from-column)))
          
          ;; Consume all columns into one tabbed column
          (do
            (action :focus-column-first)
            (action :set-column-width width)
            (action :toggle-column-tabbed-display)
            (dotimes [_ (dec unique-columns)]
              (action :consume-window-into-column))))
        
        ;; Restore focus to original window
        (action :focus-window "--id" current-id)))))

(comment
  (#'irit/toggle-monocle-mode "49%")

  (->>
   (filter
    #(= (:workspace_id %) 1)
    (msg :windows)

    )
   (map :layout)
   (map :window_size)
   )

  )

(defn force-kill-window []
  ;; todo: absorb all windows in workspace into one tabbed view, or expel out
  (shell/sh "kill" "-9" (str (:pid (msg :focused-window)))))

(comment
  (keys (msg :focused-window))

  (:layout (msg :focused-window))

  {:pos_in_scrolling_layout [2 1], :tile_size [2395.2 1572.8], :window_size [2395 1573], :tile_pos_in_workspace_view nil, :window_offset_in_tile [0.0 0.0]}
  {:pos_in_scrolling_layout [2 1], :tile_size [2947.2 1572.8], :window_size [2947 1573], :tile_pos_in_workspace_view nil, :window_offset_in_tile [0.0 0.0]}

  (:workspace_id :layout :is_floating :app_id :title :pid :is_focused :id :focus_timestamp :is_urgent)

  )

(when (= *file* (System/getProperty "babashka.file"))
  (let [cmd *command-line-args*
        result (apply (-> cmd first symbol resolve)
                      (rest cmd))]
    (cond
      (string? result) (print result)
      (and result (seqable? result)) (run! println result))))
