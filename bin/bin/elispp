#!/usr/bin/env bb
;; call emacs in various ways
;; coupled to my emacs.d
;; unfortunately this is slightly slower than the sh version ("doing nothing" takes 80ms vs 35ms on this 2020 mbp)

(ns elisp
  (:require [babashka.fs :as fs]
            [clojure.string :as string]
            [clojure.tools.cli :as cli]
            [clojure.java.shell :as shell]
            [lib.util :refer [sh shh has? home stderr]]))

(when (System/getenv "CALLED_FROM_EMACS")
  (System/exit 0))

(def verbose? nil)

(defn vlog [& xs]
  (and verbose? (stderr (apply pr-str xs))))

(defn env-export [env-map]
  (merge (into {} (System/getenv))
         env-map))

(def cli-options
  [["-t" "--timeout TIMEOUT" "set timeout"]
   ["-r" "--raw" "trim the output string"]
   ["-q" "--quiet" "do not print the result of sexp"]
   ["-b" "--batch" "run lisp in batch mode"]
   ["-w" "--window" "run lisp in batch mode with a window"] ; TODO
   ["-v" "--verbose" "verbose mode"]
   ["-h" "--help" "print usage"]])

(defn usage []
  (->> cli-options
       (map #(string/join " " (take 3 %)))
       (string/join "\n")
       (println))
  (System/exit 0))

(defn run-elisp [options lisp extra-args]
  (let [stdin (when (not (System/console))
                (string/join "\n" (line-seq (clojure.java.io/reader *in*))))
        batch? (:batch options)
        lisp (format "(let ((*stdin* %s)) %s)" (pr-str stdin) lisp)
        cmd (if batch?
              ["emacs" "--batch" "-l" (home ".emacs.d/init.el")]
              ["emacsclient" "--eval" (str lisp)])
        timeout (or (:timeout options) 4)
        cmd (if-not (has? "timeout") cmd
                    (vec (apply list "timeout" (str timeout) cmd)))]
    (vlog "options:" options)
    (vlog "cmd:" cmd)
    (let [result-cmd (eval `(shell/sh ~@cmd
                                      :env ~(env-export
                                             (merge {}
                                                    (and batch? {"NS_EMACS_BATCH" lisp})
                                                    (and (:window options) {"NS_REDIR_LOG" "true"})))))
          result (if (= 124 (:exit result-cmd))
                   "TIMED_OUT"
                   (if batch? (:err result-cmd)
                       (:out result-cmd)))

          result-raw (if-not batch? (string/trim result)
                             (->> result
                                  (string/split-lines)
                                  (drop-while (complement #{"COOL_DELIMITER"}))
                                  (rest)
                                  (string/join "\n")))
          result-raw (if (#{\" \(} (first result-raw))
                       (subs result-raw 1 (dec (count result-raw)))
                       result-raw)]
      (vlog "result: " result-cmd)
      (when-not (:quiet options)
        (println (if (:raw options)
                   result-raw
                   result)))
      (System/exit (if (#{"nil" ""} result-raw)
                     1 0)))))

(if (fs/exists? (first *command-line-args*))
  (let [file (first *command-line-args*)
        options (some->> (slurp file)
                         (string/split-lines)
                         (filter #(string/starts-with? % ";; elisp-opts:"))
                         (first))
        script-options {:raw true}]
    (def verbose? (:verbose options))
    (run-elisp (and options (merge script-options (:options (cli/parse-opts (string/split (second (string/split options #":")) #" +") cli-options))))
               (format "(let ((ns-args %s)) (->> %s f-read read eval)" (pr-str (rest *command-line-args*)) (pr-str file))
               []))
  (let [{:keys [options errors arguments]} (cli/parse-opts *command-line-args* cli-options)
        ;; todo: pass extra-args to emacsclient?
        [lisp & extra-args] arguments]
    (def verbose? (:verbose options))
    (run! stderr errors)
    (when (:help options) (usage))
    (run-elisp options lisp extra-args)))
